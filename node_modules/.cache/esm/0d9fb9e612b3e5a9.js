_12b‍.x([["ScpSecretLaboratory",()=>ScpSecretLaboratory]]);class ScpSecretLaboratory {
    constructor(message, args, settings) {
        this.settings = settings.event;
        this.eventsId = settings.serverId.scpSecretLaboratory.events.channel;
        this.scpRoleId = settings.serverId.scpSecretLaboratory.roleId;

        this.host(message, args);
    }

    host(message, args) {
        const minPeople = args[0];
        const maxPeople = args[1];
        const ip = args[2];
        const time = args[3];

        if (this.isUserAlreadyHostingEvent(message)) {
            this.userAlreadyHostingEvent(message);
            return;
        }

        if (minPeople === undefined || maxPeople === undefined || ip === undefined || ip === 'false' || time === undefined) {
            this.notFilledIn(message);
            return;
        }

        let eventMessage = this.settings.scpSecretLaboratory.host.start;

        if (time !== 'false') {
            eventMessage += this.settings.scpSecretLaboratory.host.start_time;
            if (minPeople !== 'false') {
                eventMessage += this.settings.scpSecretLaboratory.host.min;
            }
        } else {
            if (minPeople !== 'false') {
                eventMessage += this.settings.scpSecretLaboratory.host.no_start_time;
                eventMessage += this.settings.scpSecretLaboratory.host.min;
            } else {
                eventMessage += this.settings.scpSecretLaboratory.host.no_start_time_no_min;
            }
        }

        if (maxPeople !== 'false') {
            eventMessage += this.settings.scpSecretLaboratory.host.max;
        }

        eventMessage += this.settings.scpSecretLaboratory.host.end;

        const hostMessage = eventMessage
            .replace('//name//', message.author.username)
            .replace('//minPeople//', minPeople)
            .replace('//maxPeople//', maxPeople)
            .replace('//ip//', ip)
            .replace('//time//', time);

        const eventsChannel = message.channel.guild.channels.cache.get(this.eventsId);
        eventsChannel.send(hostMessage)
            .then(newMessage => {
                message.reply(this.settings.scpSecretLaboratory.host.success);
                message.delete();

                newMessage.react('👋');
                newMessage.react('❌');

                this.saveEvent(message, newMessage, hostMessage, args);
            });
    }

    saveEvent(message, newMessage, hostMessage, args) {
        const minPeople = args[0];
        const maxPeople = args[1];
        const ip = args[2];
        const time = args[3];

        const event = {
            'messageId': newMessage.id,
            'hostId': message.author.id,
            'hostname': message.author.username,
            'minPeople': minPeople,
            'maxPeople': maxPeople,
            'ip': ip,
            'time': time,
            'defaultMessage': hostMessage,
            'players': {},
            'notPlaying': {},
        };

        const fs = require('fs');

        const allEventsJson = fs.readFileSync('Events/scpSecretLaboratory.json');
        let events = {};
        if (allEventsJson) {
            events = JSON.parse(allEventsJson);
        }

        events[newMessage.id] = event;

        const jsonEvents = JSON.stringify(events);

        fs.writeFileSync('Events/scpSecretLaboratory.json', jsonEvents);
        if (event.time !== 'false') {
            this.autoStart(event, newMessage);
        }
    }

    autoStart(event, message) {
        const date = new Date();
        const currentHour = date.getHours();
        const currentMinute = date.getMinutes();
        const currentTimeInMinutes = (currentHour * 60) + currentMinute;

        const requiredTimeSplit = event.time.split(':');
        const requiredTimeInMinutes = (parseInt(requiredTimeSplit[0]) * 60) + parseInt(requiredTimeSplit[1]);

        const timeUntilStartInMinutes = requiredTimeInMinutes - currentTimeInMinutes;

        if (timeUntilStartInMinutes > 5) {
            console.log('almost starting!');
            setTimeout(() => {
                this.almostStartEvent(event, message);
            }, (timeUntilStartInMinutes - 5) * 60000);
        }

        setTimeout(() => {
            this.startEvent(event, message);
        }, timeUntilStartInMinutes * 60000);
    }

    startEvent(event, message) {
        const messageId = event.messageId;

        const fs = require('fs');

        const allEventsJson = fs.readFileSync('Events/scpSecretLaboratory.json');
        const events = JSON.parse(allEventsJson);

        if (!events[messageId]) {
            console.error('cannot start event, not found in json! messageId: ' + messageId);
            return;
        }

        const newEvent = events[messageId];

        if (parseInt(newEvent.minPeople) > Object.keys(newEvent.players).length) {
            this.stopEvent(newEvent, message);
            return;
        }

        const eventsChannel = message.channel.guild.channels.cache.get(this.eventsId);

        const eventMessage = eventsChannel.messages.cache.filter(foundMessage => foundMessage.id === messageId).first();

        eventMessage.edit('Status: STARTED \n\n' + eventMessage.content);

        delete events[messageId];

        const jsonEvents = JSON.stringify(events);
        fs.writeFileSync('Events/scpSecretLaboratory.json', jsonEvents);

        const messageToSend = this.settings.scpSecretLaboratory.isStarting.replace('//name//', newEvent.hostname);
        const keyPlayers = Object.keys(newEvent.players);

        for (let i = 0; i < keyPlayers.length; i++) {
            const playerId = keyPlayers[i];
            message.guild.members.fetch(playerId)
                .then(member => {
                    member.send(messageToSend);
                });
        }
    }

    almostStartEvent(event, message) {
        const messageId = event.messageId;

        const fs = require('fs');

        const allEventsJson = fs.readFileSync('Events/scpSecretLaboratory.json');
        const events = JSON.parse(allEventsJson);

        if (!events[messageId]) {
            console.error('cannot start event, not found in json! messageId: ' + messageId);
            return;
        }

        const newEvent = events[messageId];

        const messageToSend = this.settings.scpSecretLaboratory.isAlmostStarting.replace('//name//', newEvent.hostname);
        const keyPlayers = Object.keys(newEvent.players);

        for (let i = 0; i < keyPlayers.length; i++) {
            const playerId = keyPlayers[i];
            message.guild.members.fetch(playerId)
                .then(member => {
                    member.send(messageToSend);
                });
        }

        const allMembers = message.guild.members.fetch();

        allMembers.then(members => {
            this.sendNotReactedMembersMessage(members, message, newEvent);
        }).catch(error => {
            console.log('error');
            console.log(error);
        });

    }

    sendNotReactedMembersMessage(members, message, event) {
        const arrayMembers = members.array();
        let allUsers = [];

        for (let i = 0; i < arrayMembers.length; i++) {
            const user = arrayMembers[i];
            if (!user.user.bot && user._roles.filter(role => role === this.scpRoleId).length > 0 && !(event.players[user.user.id] || event.notPlaying[user.user.id])) {
                allUsers.push(user.user.id);
            }
        }

        const messageToSend = this.settings.scpSecretLaboratory.wantToJoin
            .replace('//name//', event.hostname);

        for (let i = 0; i < allUsers.length; i++) {
            const playerId = allUsers[i];
            message.guild.members.fetch(playerId)
                .then(member => {
                    member.send(messageToSend);
                });
        }
    }

    notFilledIn(message) {
        message.reply(this.settings.scpSecretLaboratory.notFilledIn)
            .then(() => {
                message.delete();
            });
    }

    isUserAlreadyHostingEvent(message) {
        const fs = require('fs');

        const usedId = message.author.id;

        const allEventsJson = fs.readFileSync('Events/scpSecretLaboratory.json');
        const events = JSON.parse(allEventsJson);

        for (let messageId in events) {
            if (events[messageId].hostId === usedId) {
                return true;
            }
        }

        return false;
    }

    userAlreadyHostingEvent(message) {
        message.reply(this.settings.scpSecretLaboratory.userAlreadyHostingEvent)
            .then(() => {
                message.delete();
            });
    }

    stopEvent(newEvent, message) {
        const hostId = newEvent.hostId;
        const messageId = this.getMessageIdAndRemoveEvent(hostId);

        const eventsChannel = message.channel.guild.channels.cache.get(this.eventsId);

        const eventMessage = eventsChannel.messages.cache.filter(foundMessage => foundMessage.id === messageId).first();

        eventMessage.edit('Status: STOPPED \n\n' + eventMessage.content);
    }

    getMessageIdAndRemoveEvent(hostId) {
        const fs = require('fs');

        const allEventsJson = fs.readFileSync('Events/scpSecretLaboratory.json');
        const events = JSON.parse(allEventsJson);

        for (let messageId in events) {
            if (events[messageId].hostId === hostId) {
                delete events[messageId];

                const jsonEvents = JSON.stringify(events);
                fs.writeFileSync('Events/scpSecretLaboratory.json', jsonEvents);

                return messageId;
            }
        }

        return false;
    }
}
